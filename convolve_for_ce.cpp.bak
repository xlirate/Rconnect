#include <numeric>
#include <iostream>
#include <execution>
#include <ranges>

using namespace std;

int k_width = 3 ;
int k_height = 3;
int d_width = 25;
int d_height = 25;
int o_width = 23;
int o_height = 23;

template < int (CLAMP)(int, int, int, int), bool NARROW=false, bool ZERO_OUT_OF_BOUNDS=false>
vector<double> _convolve(
    const vector<double>& data,
    const vector<double>& kernel){

  
  vector<double> output;
  output.reserve(o_height*o_width);
  
  const auto x_indexes = ranges::iota_view<int, int>(0, o_width);
  const auto y_indexes = ranges::iota_view<int, int>(0, o_height);
  
  vector<pair<int, int>> k_points;
  k_points.reserve(k_width*k_height);
  
  for(int x = 0; x<k_width; x++){
    for(int y = 0; y<k_height; y++){
      k_points.emplace_back(x,y);

    }
  }
  /*
   * Parallel stratagy
   *
   * Use threads per column, in any order
   *
   * within each column, do each data point sequentially and in any order
   *
   * within each data point, perform the multiply and add in any order and
   *  if possible all at the same time using wide vector instructions
   *
   */
  for_each(
    //execution::seq,
    //execution::par,
    execution::par_unseq,
    begin(x_indexes),
    end(x_indexes),
    [&] (auto o_x){

      for_each(
        execution::seq,
        begin(y_indexes),
        end(y_indexes),
        [&] (auto o_y){

          output[o_y+o_x*o_height] = transform_reduce(
            //execution::seq,
            execution::unseq,
            begin(k_points),
            end(k_points),
            0.0,
            plus<>{},
            [&](auto point){
              auto[k_x, k_y]= point;
              auto d_x = CLAMP(o_x, k_x, d_width,  k_width);
              auto d_y = CLAMP(o_y, k_y, d_height, k_height);
              if constexpr(ZERO_OUT_OF_BOUNDS){
                if(d_x < 0 || d_width <= d_x || d_y < 0 || d_height <= d_y){
                  return 0.0;
                }
              }
              return data[d_y+d_height*d_x]*kernel[k_y+k_height*k_x];
            });
        });
    });
  
  return output;
}

inline constexpr int _stretch(const int o_x, const int k_x, const int, const int){
  return o_x+k_x;//clamp(o_x+k_x-k_width/2, 0, d_width -1);
}


vector<double> convolve_stretch(vector<double> data, std::vector<vector<double>> kernel) {
  return accumulate(begin(kernel), end(kernel), data, _convolve<&_stretch>);
}

int main()
{
    vector<double> data{
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        };


    vector<vector<double>> kernel{{0,1,0,1,4,1,0,1,0}};


    cout << "A\n";
    vector<double> output = convolve_stretch(data, kernel);
    cout << "B\n";

    for(int x = 0; x< o_width; x++){
        for(int y = 0; y<o_height; y++){
            cout << output[y+x*o_height] << ",";
        }
        cout << "\n";
    }
    cout << "\n";
}
